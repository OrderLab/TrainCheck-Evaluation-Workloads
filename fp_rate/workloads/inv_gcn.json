{"text_description": "FunctionCoverRelation between torch.backends.cuda.is_built and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.backends.cuda.is_built and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.backends.cuda.is_built and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.cuda.graphs.is_current_stream_capturing and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.cuda.graphs.is_current_stream_capturing and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.cuda.graphs.is_current_stream_capturing and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.dropout and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.log_softmax and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.nll_loss and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.functional.relu and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.dropout.Dropout.forward and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 600, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.nn.modules.module.Module.eval", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.loss.NLLLoss.forward and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.children and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.eval and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.eval and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.eval and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.eval and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.eval and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.nn.modules.module.Module.named_parameters", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_parameters"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 5, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.named_children and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.register_parameter and torch.nn.init.xavier_normal_", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.register_parameter"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.functional.dropout", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.functional.log_softmax", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.functional.nll_loss", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.functional.relu", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.nn.modules.module.Module.train and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.optim.adamw.AdamW.step and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.optim.adamw.adamw and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.optim.adamw.adamw and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.optim.adamw.adamw and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_cover": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionCoverRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.backends.cuda.is_built", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.optim.adamw.AdamW.step", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionCoverRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.optim.adamw.adamw", "relation": "FunctionCoverRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_cover": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.module.Module.children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.module.Module.eval", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.nn.modules.module.Module.train", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.optim.adamw.adamw", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.backends.cuda.is_built and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.backends.cuda.is_built", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.module.Module.children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.module.Module.eval", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.nn.modules.module.Module.train", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.optim.adamw.adamw", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.cuda.graphs.is_current_stream_capturing and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.nn.functional.dropout and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.dropout and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.dropout and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.log_softmax and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.log_softmax and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.relu and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.relu and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.relu and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.relu and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.functional.relu and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.dropout.Dropout.forward and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.children and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2408, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.eval and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.named_parameters and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 5, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.nn.modules.module.Module.register_parameter and torch.nn.init.xavier_normal_", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.register_parameter"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.module.Module.children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.module.Module.eval", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.nn.modules.module.Module.train", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.AdamW.step and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.backends.cuda.is_built", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.module.Module.children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.module.Module.eval", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.nn.modules.module.Module.train", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.adamw.adamw and torch.optim.optimizer.Optimizer.zero_grad", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}], "precondition": {"func_lead": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [200]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 1}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.backends.cuda.is_built", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.cuda.graphs.is_current_stream_capturing", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.functional.dropout", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.functional.log_softmax", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.functional.nll_loss", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.functional.relu", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.dropout.Dropout.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.loss.NLLLoss.forward", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.module.Module.children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.module.Module.eval", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.eval"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.module.Module.named_children", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.named_children"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.nn.modules.module.Module.train", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module.train"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.optim.adamw.AdamW.step", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "FunctionLeadRelation between torch.optim.optimizer.Optimizer.zero_grad and torch.optim.adamw.adamw", "relation": "FunctionLeadRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}], "precondition": {"func_lead": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 200, "num_negative_examples": 0}
{"text_description": "TBD merged", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.zero_grad"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad", "pre_value": "non_zero", "post_value": null}], "precondition": {"parent_func_call_pre": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [0]}]}, {"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init", "evaluation"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 1}
{"text_description": "TBD merged", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "data", "pre_value": "non_zero", "post_value": "non_zero"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "TBD merged", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad", "pre_value": null, "post_value": "non_zero"}], "precondition": {"parent_func_call_pre": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}, {"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init", "evaluation"]}]}]}}, "num_positive_examples": 20, "num_negative_examples": 1}
{"text_description": "TBD merged", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "data", "pre_value": "non_zero", "post_value": "non_zero"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "TBD merged", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad", "pre_value": null, "post_value": "non_zero"}], "precondition": {"parent_func_call_pre": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}]}, {"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init", "evaluation"]}]}]}}, "num_positive_examples": 20, "num_negative_examples": 1}
{"text_description": "The value 1433 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 7 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value 91712 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [0, 'name'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'grad_fn'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'grad_fn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["grad_fn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 401, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'name'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value None is consistent across the input [1, 'name'] and output [0, 'name'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["name"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.dropout is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.log_softmax is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.nll_loss is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.relu is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.functional.dropout is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.functional.log_softmax is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.functional.nll_loss is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.functional.relu is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.dropout is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.dropout is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.log_softmax is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.log_softmax is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.nll_loss is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.nll_loss is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.relu is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.functional.relu is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently <NA>.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": "NOT SERIALIZABLE: <NA>"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 199, "num_negative_examples": 401}
{"text_description": "grad_fn of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "grad_fn", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 199}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.dropout is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.log_softmax is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.nll_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.dropout is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.log_softmax is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.nll_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.dropout is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.log_softmax is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.nll_loss is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.relu is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.functional.dropout is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.functional.log_softmax is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.functional.nll_loss is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.functional.relu is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "name of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently None.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "name", "const_value": null}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.dropout is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.log_softmax is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.nll_loss is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.relu is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.dropout is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.log_softmax is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.nll_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 401, "num_negative_examples": 200}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 200, "num_negative_examples": 401}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.dropout is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.log_softmax is consistently (2708, 7).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 7]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.nll_loss is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.relu is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 601, "num_negative_examples": 0}
{"text_description": "torch.library.Library.impl has distinct input arguments on difference PT for each step", "relation": "DistinctArgumentRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.library.Library.impl"}], "precondition": {"distinct_arg": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 3, "num_negative_examples": 0}
{"text_description": "torch.nn.functional.nll_loss has distinct input arguments on difference PT for each step", "relation": "DistinctArgumentRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}], "precondition": {"distinct_arg": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 600, "num_negative_examples": 0}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.is_grad_enabled with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.nn.init._calculate_fan_in_and_fan_out with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_fan_in_and_fan_out"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.nn.init._no_grad_normal_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_normal_", "arguments": {"args": {"mean": {"float": 0.0}, "generator": {"NoneType": null}}, "func_name": "torch.nn.init._no_grad_normal_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "torch.nn.modules.dropout.Dropout.forward contains torch.nn.functional.dropout with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout", "arguments": {"args": {"p": {"float": 0.5}, "training": {"bool": true}, "inplace": {"bool": false}}, "func_name": "torch.nn.functional.dropout"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 23, "num_negative_examples": 0}
{"text_description": "torch.nn.modules.dropout.Dropout.forward contains torch.nn.functional.dropout with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout", "arguments": {"args": {"p": {"float": 0.5}, "training": {"bool": false}, "inplace": {"bool": false}}, "func_name": "torch.nn.functional.dropout"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": 26, "num_negative_examples": 0}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward contains torch.nn._reduction.get_enum with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn._reduction.get_enum", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn._reduction.get_enum"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training", "evaluation"]}]}]}}, "num_positive_examples": 48, "num_negative_examples": 0}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward contains torch.nn.functional.nll_loss with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss", "arguments": {"args": {"weight": {"NoneType": null}, "ignore_index": {"int": -100}, "reduction": {"str": "mean"}}, "func_name": "torch.nn.functional.nll_loss"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training", "evaluation"]}]}]}}, "num_positive_examples": 48, "num_negative_examples": 0}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward has distinct input arguments on difference PT for each step", "relation": "DistinctArgumentRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}], "precondition": {"distinct_arg": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": 600, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_add_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_addcdiv_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcdiv_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_addcmul_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_div_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_lerp_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_lerp_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_mul_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass._foreach_sqrt with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass.is_complex with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.is_complex"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass.tensor with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tensor"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 23, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._VariableFunctionsClass.zeros_like with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.zeros_like", "arguments": {"args": {"memory_format": {"memory_format": {}}}, "func_name": "torch._VariableFunctionsClass.zeros_like"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "int", "values": [1]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 4, "num_negative_examples": 20}
{"text_description": "torch.optim.adamw.AdamW.step contains torch._utils.is_compiling with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 189, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.backends.cuda.is_built with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.cuda._nvml_based_avail with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.cuda.graphs.is_current_stream_capturing with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.is_grad_enabled with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 126, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.adamw.AdamW._init_group with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW._init_group", "arguments": {"args": {"self": {"torch.optim.adamw.AdamW": {}}, "group": {"dict": {"lr": 0.01, "eps": 1e-08, "weight_decay": 0.0005, "amsgrad": false, "foreach": null, "maximize": false, "capturable": false, "differentiable": false, "fused": null}}, "params_with_grad": {"list": []}, "grads": {"list": []}, "amsgrad": {"bool": false}, "exp_avgs": {"list": []}, "exp_avg_sqs": {"list": []}, "max_exp_avg_sqs": {"list": []}, "state_steps": {"list": []}}, "func_name": "torch.optim.adamw.AdamW._init_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.adamw._multi_tensor_adamw with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw._multi_tensor_adamw", "arguments": {"args": {"amsgrad": {"bool": false}, "beta1": {"float": 0.9}, "beta2": {"float": 0.999}, "lr": {"float": 0.01}, "weight_decay": {"float": 0.0005}, "eps": {"float": 1e-08}, "maximize": {"bool": false}, "capturable": {"bool": false}, "differentiable": {"bool": false}, "grad_scale": {"NoneType": null}, "found_inf": {"NoneType": null}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "exp_avgs": {"list": {}}, "exp_avg_sqs": {"list": {}}, "max_exp_avg_sqs": {"list": []}, "state_steps": {"list": {}}}, "func_name": "torch.optim.adamw._multi_tensor_adamw"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.adamw.adamw with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw", "arguments": {"args": {"amsgrad": {"bool": false}, "beta1": {"float": 0.9}, "beta2": {"float": 0.999}, "lr": {"float": 0.01}, "weight_decay": {"float": 0.0005}, "eps": {"float": 1e-08}, "maximize": {"bool": false}, "foreach": {"NoneType": null}, "capturable": {"bool": false}, "differentiable": {"bool": false}, "fused": {"NoneType": null}, "grad_scale": {"NoneType": null}, "found_inf": {"NoneType": null}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "exp_avgs": {"list": {}}, "exp_avg_sqs": {"list": {}}, "max_exp_avg_sqs": {"list": []}, "state_steps": {"list": {}}}, "func_name": "torch.optim.adamw.adamw"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check", "arguments": {"args": {"self": {"torch.optim.adamw.AdamW": {}}}, "func_name": "torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.optimizer._default_to_fused_or_foreach with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.optimizer._dispatch_sqrt with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._dispatch_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.optimizer._get_value with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._get_value"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 84, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.optim.optimizer._stack_if_compiling with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._stack_if_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.utils._foreach_utils._get_fused_kernels_supported_devices with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.AdamW.step contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.AdamW.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_add_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_addcdiv_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcdiv_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_addcmul_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_div_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_lerp_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_lerp_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_mul_ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass._foreach_sqrt with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._VariableFunctionsClass.tensor with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tensor", "arguments": {"args": {"device": {"str": "cpu"}}, "func_name": "torch._VariableFunctionsClass.tensor"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch._utils.is_compiling with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 168, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.is_grad_enabled with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 63, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.optim.adamw._multi_tensor_adamw with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adamw._multi_tensor_adamw", "arguments": {"args": {"amsgrad": {"bool": false}, "beta1": {"float": 0.9}, "beta2": {"float": 0.999}, "lr": {"float": 0.01}, "weight_decay": {"float": 0.0005}, "eps": {"float": 1e-08}, "maximize": {"bool": false}, "capturable": {"bool": false}, "differentiable": {"bool": false}, "grad_scale": {"NoneType": null}, "found_inf": {"NoneType": null}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "exp_avgs": {"list": {}}, "exp_avg_sqs": {"list": {}}, "max_exp_avg_sqs": {"list": []}, "state_steps": {"list": {}}}, "func_name": "torch.optim.adamw._multi_tensor_adamw"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.optim.optimizer._default_to_fused_or_foreach with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.optim.optimizer._dispatch_sqrt with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._dispatch_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 42, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.optim.optimizer._get_value with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._get_value"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 84, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.optim.optimizer._stack_if_compiling with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._stack_if_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.utils._foreach_utils._get_fused_kernels_supported_devices with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.adamw.adamw contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adamw.adamw"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": 21, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._compile._disable_dynamo with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._compile._disable_dynamo"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._guards.Guard.__init__ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._guards.Guard.__init__", "arguments": {"args": {"self": {"torch._guards.Guard": {"code_list": null, "guard_types": null, "guarded_class_weakref": null, "obj_weakref": null, "stack": null, "user_stack": null}}, "originating_source": {"torch._dynamo.source.GlobalStateSource": {}}}, "func_name": "torch._guards.Guard.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 3, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._logging._internal.LogRegistry.is_off_by_default with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._logging._internal.LogRegistry.is_off_by_default", "arguments": {"args": {"self": {"torch._logging._internal.LogRegistry": {}}}, "func_name": "torch._logging._internal.LogRegistry.is_off_by_default"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 15, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._logging._internal.LogRegistry.register_artifact_log with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._logging._internal.LogRegistry.register_artifact_log", "arguments": {"args": {"self": {"torch._logging._internal.LogRegistry": {}}}, "func_name": "torch._logging._internal.LogRegistry.register_artifact_log"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 15, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._logging._internal.LogState.is_artifact_enabled with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._logging._internal.LogState.is_artifact_enabled", "arguments": {"args": {"self": {"torch._logging._internal.LogState": {}}}, "func_name": "torch._logging._internal.LogState.is_artifact_enabled"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 15, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._logging._internal.configure_artifact_log with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._logging._internal.configure_artifact_log"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 15, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._logging._internal.getArtifactLogger with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._logging._internal.getArtifactLogger"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 15, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._ops.HigherOrderOperator.fallthrough with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._ops.HigherOrderOperator.fallthrough", "arguments": {"args": {"self": {"torch._ops.higher_order.trace_wrapped": {}}}, "func_name": "torch._ops.HigherOrderOperator.fallthrough"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._ops.HigherOrderOperator.py_impl with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._ops.HigherOrderOperator.py_impl", "arguments": {"args": {"self": {"torch._ops.higher_order.trace_wrapped": {}}}, "func_name": "torch._ops.HigherOrderOperator.py_impl"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 7, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._ops.OperatorBase.__init__ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._ops.OperatorBase.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._ops.OperatorBase.py_impl with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._ops.OperatorBase.py_impl", "arguments": {"args": {"self": {"torch._ops.higher_order.trace_wrapped": {}}}, "func_name": "torch._ops.OperatorBase.py_impl"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 7, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._vendor.packaging.version.Version.__init__ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._vendor.packaging.version.Version.__init__", "arguments": {"args": {"self": {"torch._vendor.packaging.version.Version": {}}, "version": {"torch.torch_version.TorchVersion": "2.2.2+cu121"}}, "func_name": "torch._vendor.packaging.version.Version.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._vendor.packaging.version._cmpkey with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._vendor.packaging.version._cmpkey", "arguments": {"args": {"epoch": {"int": 0}, "release": {"tuple": [2, 2, 2]}, "pre": {"NoneType": null}, "post": {"NoneType": null}, "dev": {"NoneType": null}, "local": {"tuple": ["cu121"]}}, "func_name": "torch._vendor.packaging.version._cmpkey"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._vendor.packaging.version._parse_letter_version with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._vendor.packaging.version._parse_letter_version", "arguments": {"args": {"letter": {"NoneType": null}, "number": {"NoneType": null}}, "func_name": "torch._vendor.packaging.version._parse_letter_version"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 18, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch._vendor.packaging.version._parse_local_version with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch._vendor.packaging.version._parse_local_version", "arguments": {"args": {"local": {"str": "cu121"}}, "func_name": "torch._vendor.packaging.version._parse_local_version"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch.distributed.is_available with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 4, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch.library.Library.__init__ with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch.library.Library.__init__", "arguments": {"args": {"self": {"torch.library.Library": {}}, "ns": {"str": "_inductor_test"}}, "func_name": "torch.library.Library.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 2, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch.library.Library.impl with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch.library.Library.impl", "arguments": {"args": {"self": {"torch.library.Library": {"dispatch_key": "", "kind": "IMPL", "ns": "_inductor_test"}}, "op_name": {"str": "realize"}, "fn": {"torch._inductor.test_operators.<lambda>": {}}}, "func_name": "torch.library.Library.impl"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 3, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch.torch_version.TorchVersion._cmp_wrapper with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch.torch_version.TorchVersion._cmp_wrapper", "arguments": {"args": {"self": {"torch.torch_version.TorchVersion": "2.2.2+cu121"}, "method": {"str": "__eq__"}}, "func_name": "torch.torch_version.TorchVersion._cmp_wrapper"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
{"text_description": "torch.optim.optimizer.Optimizer.add_param_group contains torch.torch_version.TorchVersion._convert_to_version with exception: NOT SET", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.add_param_group"}, {"param_type": "APIParam", "api_full_name": "torch.torch_version.TorchVersion._convert_to_version", "arguments": {"args": {"self": {"torch.torch_version.TorchVersion": "2.2.2+cu121"}}, "func_name": "torch.torch_version.TorchVersion._convert_to_version"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["init"]}]}]}}, "num_positive_examples": 6, "num_negative_examples": 0}
