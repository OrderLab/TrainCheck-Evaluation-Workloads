{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch._VariableFunctionsClass._amp_foreach_non_finite_check_and_unscale_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._amp_foreach_non_finite_check_and_unscale_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_", "arguments": {"args": {"alpha": {"float": -0.001}}, "func_name": "torch._VariableFunctionsClass._foreach_add_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch._VariableFunctionsClass.full <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.full", "arguments": {"args": {"dtype": {"torch.dtype": "torch.float32"}, "device": {"device": {"index": 0, "type": "cuda"}}}, "func_name": "torch._VariableFunctionsClass.full"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch._ops.OpOverload.__call__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch._ops.OpOverload.__call__", "arguments": {"args": {"self": {"torch._ops.profiler.profiler::_record_function_exit._RecordFunction": {"is_view": false, "namespace": "profiler"}}, "args": {"torch._RecordFunction": {}}}, "func_name": "torch._ops.OpOverload.__call__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.profiler.record_function.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.profiler.record_function.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.autograd.profiler.record_function.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler.GradScaler._maybe_opt_step <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._maybe_opt_step", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "optimizer": {"torch.optim.sgd.SGD": {}}, "optimizer_state": {"dict": {}}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._maybe_opt_step"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "optimizer": {"torch.optim.sgd.SGD": {}}, "allow_fp16": {"bool": false}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler.GradScaler.unscale_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "optimizer": {"torch.optim.sgd.SGD": {}}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler._MultiDeviceReplicator.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler._MultiDeviceReplicator.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler._MultiDeviceReplicator.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler._MultiDeviceReplicator.get"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.cuda.amp.grad_scaler._refresh_per_optimizer_state <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler._refresh_per_optimizer_state"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.optimizer.Optimizer._optimizer_step_code <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer._optimizer_step_code", "arguments": {"args": {"self": {"torch.optim.sgd.SGD": {}}}, "func_name": "torch.optim.optimizer.Optimizer._optimizer_step_code"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"differentiable": {"bool": false}, "use_fused": {"bool": false}, "params": {"list": {}}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.sgd.SGD._init_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD._init_group", "arguments": {"args": {"self": {"torch.optim.sgd.SGD": {}}, "group": {"dict": {}}, "params_with_grad": {"list": []}, "d_p_list": {"list": []}, "momentum_buffer_list": {"list": []}}, "func_name": "torch.optim.sgd.SGD._init_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.sgd.SGD.step <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step", "arguments": {"args": {"self": {"torch.optim.sgd.SGD": {}}}, "func_name": "torch.optim.sgd.SGD.step"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.sgd._multi_tensor_sgd <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.sgd._multi_tensor_sgd", "arguments": {"args": {"weight_decay": {"int": 0}, "momentum": {"int": 0}, "lr": {"float": 0.001}, "dampening": {"int": 0}, "nesterov": {"bool": false}, "has_sparse_grad": {"bool": false}, "maximize": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "momentum_buffer_list": {"list": [null, null, null, null, null, null]}}, "func_name": "torch.optim.sgd._multi_tensor_sgd"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.optim.sgd.sgd <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd", "arguments": {"args": {"weight_decay": {"int": 0}, "momentum": {"int": 0}, "lr": {"float": 0.001}, "dampening": {"int": 0}, "nesterov": {"bool": false}, "maximize": {"bool": false}, "has_sparse_grad": {"bool": false}, "foreach": {"NoneType": null}, "params": {"list": {}}, "d_p_list": {"list": {}}, "momentum_buffer_list": {"list": [null, null, null, null, null, null]}}, "func_name": "torch.optim.sgd.sgd"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.step contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": true}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch._VariableFunctionsClass._amp_foreach_non_finite_check_and_unscale_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._amp_foreach_non_finite_check_and_unscale_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch._VariableFunctionsClass.full <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.full", "arguments": {"args": {"dtype": {"torch.dtype": "torch.float32"}, "device": {"device": {"index": 0, "type": "cuda"}}}, "func_name": "torch._VariableFunctionsClass.full"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "funcname": {"str": "unscale_"}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "optimizer": {"torch.optim.sgd.SGD": {}}, "allow_fp16": {"bool": false}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._unscale_grads_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.cuda.amp.grad_scaler._MultiDeviceReplicator.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler._MultiDeviceReplicator.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.cuda.amp.grad_scaler._MultiDeviceReplicator.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler._MultiDeviceReplicator.get"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.unscale_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.unscale_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.update contains torch._VariableFunctionsClass._amp_update_scale_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.update"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._amp_update_scale_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.amp.grad_scaler.GradScaler.update contains torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.update"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker", "arguments": {"args": {"self": {"torch.cuda.amp.grad_scaler.GradScaler": {}}, "funcname": {"str": "update"}}, "func_name": "torch.cuda.amp.grad_scaler.GradScaler._check_scale_growth_tracker"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda.memory.memory_stats <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats", "arguments": {"args": {"device": {"NoneType": null}}, "func_name": "torch.cuda.memory.memory_stats"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.max_memory_allocated contains torch.cuda.memory.memory_stats_as_nested_dict <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict", "arguments": {"args": {"device": {"NoneType": null}}, "func_name": "torch.cuda.memory.memory_stats_as_nested_dict"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats contains torch.cuda.memory.memory_stats_as_nested_dict <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict", "arguments": {"args": {"device": {"NoneType": null}}, "func_name": "torch.cuda.memory.memory_stats_as_nested_dict"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.memory_stats_as_nested_dict contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.memory_stats_as_nested_dict"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_max_memory_allocated contains torch.cuda.memory.reset_peak_memory_stats <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_max_memory_allocated"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats", "arguments": {"args": {"device": {"NoneType": null}}, "func_name": "torch.cuda.memory.reset_peak_memory_stats"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.memory.reset_peak_memory_stats contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.memory.reset_peak_memory_stats"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.random.manual_seed_all contains torch.cuda._lazy_call <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.random.manual_seed_all"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_call", "arguments": {"args": {"seed_all": {"bool": true}, "callable": {"torch.cuda.random.manual_seed_all.<locals>.cb": {}}}, "func_name": "torch.cuda._lazy_call"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.random.manual_seed_all contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.random.manual_seed_all"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.set_device contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.set_device"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch._utils._get_available_device_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_available_device_type"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch._utils._get_current_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_current_device_index"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch._utils._get_device_attr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_attr", "arguments": {"args": {"get_member": {"torch._utils._get_current_device_index.<locals>.<lambda>": {}}}, "func_name": "torch._utils._get_device_attr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_device_index", "arguments": {"args": {"device": {"NoneType": null}, "optional": {"bool": true}, "allow_cpu": {"bool": false}}, "func_name": "torch._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda._lazy_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda._utils._get_device_index <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._utils._get_device_index", "arguments": {"args": {"optional": {"bool": true}, "device": {"NoneType": null}}, "func_name": "torch.cuda._utils._get_device_index"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.current_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.current_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.device.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.device.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.device.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.device.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.device.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.device.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.cuda.synchronize contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.synchronize"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.destroy_process_group contains torch.distributed.distributed_c10d._update_default_pg <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.destroy_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._update_default_pg", "arguments": {"args": {"pg": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._update_default_pg"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_backend contains torch.distributed.distributed_c10d._get_default_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_backend"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_default_group"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_backend contains torch.distributed.distributed_c10d._rank_not_in_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_backend"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._rank_not_in_group", "arguments": {"args": {"group": {"torch.distributed.distributed_c10d.ProcessGroup": {"group_name": "0"}}}, "func_name": "torch.distributed.distributed_c10d._rank_not_in_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_backend contains torch.distributed.distributed_c10d.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_backend"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_rank contains torch.distributed.distributed_c10d._get_default_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_rank"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_default_group"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_rank contains torch.distributed.distributed_c10d._rank_not_in_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_rank"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._rank_not_in_group", "arguments": {"args": {"group": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._rank_not_in_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_rank contains torch.distributed.distributed_c10d.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_rank"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_world_size contains torch.distributed.distributed_c10d._get_default_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_world_size"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_default_group"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_world_size contains torch.distributed.distributed_c10d._get_group_size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_world_size"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_group_size", "arguments": {"args": {"group": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._get_group_size"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_world_size contains torch.distributed.distributed_c10d._rank_not_in_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_world_size"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._rank_not_in_group", "arguments": {"args": {"group": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._rank_not_in_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.get_world_size contains torch.distributed.distributed_c10d.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_world_size"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.cuda.nccl.version <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.nccl.version"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.c10d_logger._get_msg_dict <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.c10d_logger._get_msg_dict", "arguments": {"args": {"backend": {"str": "nccl"}, "world_size": {"int": 8}, "func_name": {"str": "init_process_group"}}, "func_name": "torch.distributed.c10d_logger._get_msg_dict"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.BackendConfig.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.BackendConfig.__init__", "arguments": {"args": {"self": {"torch.distributed.distributed_c10d.BackendConfig": {}}, "backend": {"str": "nccl"}}, "func_name": "torch.distributed.distributed_c10d.BackendConfig.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.BackendConfig.get_device_backend_map <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.BackendConfig.get_device_backend_map", "arguments": {"args": {"self": {"torch.distributed.distributed_c10d.BackendConfig": {}}}, "func_name": "torch.distributed.distributed_c10d.BackendConfig.get_device_backend_map"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.PyCapsule.get_debug_level <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.PyCapsule.get_debug_level"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._check_valid_timeout <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._check_valid_timeout", "arguments": {"args": {"timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}}, "func_name": "torch.distributed.distributed_c10d._check_valid_timeout"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._get_default_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_default_group"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._get_default_timeout <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_default_timeout", "arguments": {"args": {"backend": {"str": "nccl"}}, "func_name": "torch.distributed.distributed_c10d._get_default_timeout"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._get_group_size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_group_size", "arguments": {"args": {"group": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._get_group_size"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._get_process_group_name <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._get_process_group_name", "arguments": {"args": {"pg": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d._get_process_group_name"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._is_barrier_after_init <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._is_barrier_after_init"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._new_process_group_helper <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._new_process_group_helper", "arguments": {"args": {"pg_options": {"NoneType": null}, "timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}, "group_size": {"int": 8}, "global_ranks_in_group": {"list": []}, "backend": {"str": "nccl"}, "store": {"torch.distributed.distributed_c10d.PrefixStore": {}}, "group_name": {"str": "0"}}, "func_name": "torch.distributed.distributed_c10d._new_process_group_helper"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._process_group_name <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._process_group_name", "arguments": {"args": {"use_hashed_name": {"bool": false}, "ranks": {"list": []}}, "func_name": "torch.distributed.distributed_c10d._process_group_name"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._rank_not_in_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._rank_not_in_group"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d._update_default_pg <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d._update_default_pg", "arguments": {"args": {"pg": {"torch.distributed.distributed_c10d.ProcessGroup": {"group_name": "0"}}}, "func_name": "torch.distributed.distributed_c10d._update_default_pg"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.get_backend <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_backend", "arguments": {"args": {"group": {"NoneType": null}}, "func_name": "torch.distributed.distributed_c10d.get_backend"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.get_rank <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_rank"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.get_world_size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.get_world_size"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.distributed_c10d.is_nccl_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.is_nccl_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.rendezvous._create_c10d_store <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._create_c10d_store", "arguments": {"args": {"hostname": {"str": "localhost"}, "port": {"int": 12355}, "world_size": {"int": 8}, "timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}, "use_libuv": {"bool": false}}, "func_name": "torch.distributed.rendezvous._create_c10d_store"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.rendezvous._query_to_dict <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._query_to_dict"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.rendezvous._rendezvous_helper <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._rendezvous_helper", "arguments": {"args": {"timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}, "url": {"str": "env://"}, "world_size_opt": {"int": 8}}, "func_name": "torch.distributed.rendezvous._rendezvous_helper"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.rendezvous._torchelastic_use_agent_store <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._torchelastic_use_agent_store"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.distributed_c10d.init_process_group contains torch.distributed.rendezvous.rendezvous <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.distributed_c10d.init_process_group"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous.rendezvous", "arguments": {"args": {"timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}, "url": {"str": "env://"}, "world_size": {"int": 8}}, "func_name": "torch.distributed.rendezvous.rendezvous"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.rendezvous.rendezvous contains torch.distributed.rendezvous._query_to_dict <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous.rendezvous"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._query_to_dict", "arguments": {"args": {"query": {"str": ""}}, "func_name": "torch.distributed.rendezvous._query_to_dict"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.distributed.rendezvous.rendezvous contains torch.distributed.rendezvous._rendezvous_helper <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous.rendezvous"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.rendezvous._rendezvous_helper", "arguments": {"args": {"timeout": {"timedelta": {"days": 0, "microseconds": 0, "seconds": 600}}, "url": {"str": "env://"}, "world_size_opt": {"int": 8}}, "func_name": "torch.distributed.rendezvous._rendezvous_helper"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.library.impl_abstract contains torch._library.utils.get_source <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.library.impl_abstract"}, {"param_type": "APIParam", "api_full_name": "torch._library.utils.get_source", "arguments": {"args": {"stacklevel": {"int": 3}}, "func_name": "torch._library.utils.get_source"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_storage_fd contains torch.multiprocessing.reductions.SharedCache.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_storage_fd"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.SharedCache.get", "arguments": {"args": {"self": {"torch.multiprocessing.reductions.SharedCache": {"limit": 128}}}, "func_name": "torch.multiprocessing.reductions.SharedCache.get"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_storage_fd contains torch.multiprocessing.reductions.SharedCache.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_storage_fd"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.SharedCache.get"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_storage_fd contains torch.multiprocessing.reductions.StorageWeakRef.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_storage_fd"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.StorageWeakRef.__init__", "arguments": {"args": {"self": {"torch.multiprocessing.reductions.StorageWeakRef": {}}, "storage": {"torch.storage.UntypedStorage": {"filename": "filename not specified", "is_cuda": false, "is_hpu": false, "is_sparse": false, "is_sparse_csr": false}}}, "func_name": "torch.multiprocessing.reductions.StorageWeakRef.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_storage_fd contains torch.multiprocessing.reductions.fd_id <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_storage_fd"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.fd_id"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_storage_fd contains torch.multiprocessing.reductions.storage_from_cache <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_storage_fd"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.storage_from_cache", "arguments": {"args": {"cls": {"torch.storage.UntypedStorage": {"is_sparse": false, "is_sparse_csr": false}}}, "func_name": "torch.multiprocessing.reductions.storage_from_cache"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_tensor contains torch._VariableFunctionsClass.tensor <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tensor", "arguments": {"args": {"device": {"device": {"type": "cpu"}}}, "func_name": "torch._VariableFunctionsClass.tensor"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_tensor contains torch._utils._rebuild_tensor <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "APIParam", "api_full_name": "torch._utils._rebuild_tensor", "arguments": {"args": {"storage_offset": {"int": 0}}, "func_name": "torch._utils._rebuild_tensor"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.rebuild_typed_storage contains torch.storage.TypedStorage.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_typed_storage"}, {"param_type": "APIParam", "api_full_name": "torch.storage.TypedStorage.__init__", "arguments": {"args": {"wrap_storage": {"torch.storage.UntypedStorage": {"filename": "filename not specified", "is_cuda": false, "is_hpu": false, "is_sparse": false, "is_sparse_csr": false}}, "_internal": {"bool": true}, "self": {"torch.storage.TypedStorage": {"is_sparse": false}}}, "func_name": "torch.storage.TypedStorage.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.storage_from_cache contains torch.multiprocessing.reductions.SharedCache.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.storage_from_cache"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.SharedCache.get", "arguments": {"args": {"self": {"torch.multiprocessing.reductions.SharedCache": {"limit": 128}}}, "func_name": "torch.multiprocessing.reductions.SharedCache.get"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.reductions.storage_from_cache contains torch.multiprocessing.reductions.SharedCache.get <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.storage_from_cache"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.SharedCache.get"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.spawn.spawn contains torch.multiprocessing.spawn.ProcessContext.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.spawn"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.ProcessContext.__init__", "arguments": {"args": {"self": {"torch.multiprocessing.spawn.ProcessContext": {}}, "processes": {"list": {}}, "error_queues": {"list": {}}}, "func_name": "torch.multiprocessing.spawn.ProcessContext.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.spawn.spawn contains torch.multiprocessing.spawn.ProcessContext.join <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.spawn"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.ProcessContext.join", "arguments": {"args": {"self": {"torch.multiprocessing.spawn.ProcessContext": {}}}, "func_name": "torch.multiprocessing.spawn.ProcessContext.join"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.spawn.spawn contains torch.multiprocessing.spawn.start_processes <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.spawn"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.start_processes", "arguments": {"args": {"start_method": {"str": "spawn"}, "fn": {"__main__.main": {}}, "args": {"tuple": [8, 2, 1, 8]}, "nprocs": {"int": 8}, "join": {"bool": true}, "daemon": {"bool": false}}, "func_name": "torch.multiprocessing.spawn.start_processes"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.spawn.start_processes contains torch.multiprocessing.spawn.ProcessContext.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.start_processes"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.ProcessContext.__init__", "arguments": {"args": {"self": {"torch.multiprocessing.spawn.ProcessContext": {}}, "processes": {"list": {}}, "error_queues": {"list": {}}}, "func_name": "torch.multiprocessing.spawn.ProcessContext.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.multiprocessing.spawn.start_processes contains torch.multiprocessing.spawn.ProcessContext.join <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.start_processes"}, {"param_type": "APIParam", "api_full_name": "torch.multiprocessing.spawn.ProcessContext.join", "arguments": {"args": {"self": {"torch.multiprocessing.spawn.ProcessContext": {}}}, "func_name": "torch.multiprocessing.spawn.ProcessContext.join"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.nn.init._calculate_correct_fan <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_correct_fan", "arguments": {"args": {"mode": {"str": "fan_in"}}, "func_name": "torch.nn.init._calculate_correct_fan"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.nn.init._calculate_fan_in_and_fan_out <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_fan_in_and_fan_out"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.kaiming_uniform_ contains torch.nn.init.calculate_gain <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.calculate_gain", "arguments": {"args": {"nonlinearity": {"str": "leaky_relu"}, "param": {"float": 2.23606797749979}}, "func_name": "torch.nn.init.calculate_gain"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.normal_ contains torch.nn.init._no_grad_normal_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_normal_", "arguments": {"args": {"std": {"float": 0.02}, "generator": {"NoneType": null}}, "func_name": "torch.nn.init._no_grad_normal_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.ones_ contains torch.nn.init._no_grad_fill_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_fill_", "arguments": {"args": {"val": {"float": 1.0}}, "func_name": "torch.nn.init._no_grad_fill_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.uniform_ contains torch.nn.init._no_grad_uniform_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_uniform_", "arguments": {"args": {"generator": {"NoneType": null}}, "func_name": "torch.nn.init._no_grad_uniform_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.nn.init._calculate_fan_in_and_fan_out <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_fan_in_and_fan_out"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.xavier_normal_ contains torch.nn.init._no_grad_normal_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_normal_", "arguments": {"args": {"mean": {"float": 0.0}, "generator": {"NoneType": null}}, "func_name": "torch.nn.init._no_grad_normal_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.init.zeros_ contains torch.nn.init._no_grad_zero_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_zero_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.activation.Sigmoid.forward contains torch._VariableFunctionsClass.sigmoid <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.sigmoid"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.activation.Tanh.forward contains torch._VariableFunctionsClass.tanh <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tanh"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.container.Sequential.forward contains torch.nn.modules.module.Module._call_impl <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module._call_impl"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.container.Sequential.forward contains torch.nn.modules.module.Module._wrapped_call_impl <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module._wrapped_call_impl"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.conv.Conv2d.forward contains torch._VariableFunctionsClass.conv2d <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.conv2d"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.conv.Conv2d.forward contains torch.nn.modules.conv.Conv2d._conv_forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d._conv_forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.conv.ConvTranspose2d.forward contains torch._VariableFunctionsClass.conv_transpose2d <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.conv_transpose2d"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.conv.ConvTranspose2d.forward contains torch.nn.modules.conv._ConvTransposeNd._output_padding <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv._ConvTransposeNd._output_padding"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.conv.ConvTranspose2d.forward contains torch.nn.modules.utils._ntuple.<locals>.parse <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.utils._ntuple.<locals>.parse"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.dropout.Dropout.forward contains torch.nn.functional.dropout <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout", "arguments": {"args": {"training": {"bool": false}, "inplace": {"bool": false}}, "func_name": "torch.nn.functional.dropout"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}, {"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.dropout.Dropout.forward contains torch.nn.functional.dropout <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout", "arguments": {"args": {"training": {"bool": true}, "inplace": {"bool": false}}, "func_name": "torch.nn.functional.dropout"}}], "precondition": {"parent_func_call_pre": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init._calculate_correct_fan <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_correct_fan", "arguments": {"args": {"mode": {"str": "fan_in"}}, "func_name": "torch.nn.init._calculate_correct_fan"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init._calculate_fan_in_and_fan_out <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._calculate_fan_in_and_fan_out"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init._no_grad_uniform_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init._no_grad_uniform_", "arguments": {"args": {"generator": {"NoneType": null}}, "func_name": "torch.nn.init._no_grad_uniform_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init.calculate_gain <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.calculate_gain", "arguments": {"args": {"nonlinearity": {"str": "leaky_relu"}, "param": {"float": 2.23606797749979}}, "func_name": "torch.nn.init.calculate_gain"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init.kaiming_uniform_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_", "arguments": {"args": {"a": {"float": 2.23606797749979}}, "func_name": "torch.nn.init.kaiming_uniform_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.linear.Linear.reset_parameters contains torch.nn.init.uniform_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.reset_parameters"}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCELoss.forward contains torch._VariableFunctionsClass.equal <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.equal"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCELoss.forward contains torch.nn._reduction.get_enum <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn._reduction.get_enum", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn._reduction.get_enum"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCELoss.forward contains torch.nn.functional.binary_cross_entropy <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy", "arguments": {"args": {"weight": {"NoneType": null}, "reduction": {"str": "mean"}}, "func_name": "torch.nn.functional.binary_cross_entropy"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCEWithLogitsLoss.forward contains torch._VariableFunctionsClass.binary_cross_entropy_with_logits <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.binary_cross_entropy_with_logits"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCEWithLogitsLoss.forward contains torch.nn._reduction.get_enum <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn._reduction.get_enum", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn._reduction.get_enum"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.BCEWithLogitsLoss.forward contains torch.nn.functional.binary_cross_entropy_with_logits <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits", "arguments": {"args": {"pos_weight": {"NoneType": null}, "reduction": {"str": "mean"}, "weight": {"NoneType": null}}, "func_name": "torch.nn.functional.binary_cross_entropy_with_logits"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.functional.broadcast_tensors <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.nn._reduction.get_enum <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn._reduction.get_enum", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn._reduction.get_enum"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.nn.functional.mse_loss <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn.functional.mse_loss"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.overrides._get_overloaded_args <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.overrides._get_overloaded_args", "arguments": {"args": {"relevant_args": {"tuple": {}}}, "func_name": "torch.overrides._get_overloaded_args"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.overrides._pop_mode <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.overrides._pop_mode"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.overrides._pop_mode_temporarily <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.overrides._pop_mode_temporarily"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.MSELoss.forward contains torch.overrides._push_mode <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.overrides._push_mode", "arguments": {"args": {"mode": {"torch.utils._device.DeviceContext": {}}}, "func_name": "torch.overrides._push_mode"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward contains torch._VariableFunctionsClass.equal <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.equal"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward contains torch.nn._reduction.get_enum <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn._reduction.get_enum", "arguments": {"args": {"reduction": {"str": "mean"}}, "func_name": "torch.nn._reduction.get_enum"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.modules.loss.NLLLoss.forward contains torch.nn.functional.nll_loss <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss", "arguments": {"args": {"weight": {"NoneType": null}, "ignore_index": {"int": -100}, "reduction": {"str": "mean"}}, "func_name": "torch.nn.functional.nll_loss"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch._ops.OpOverload.__call__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch._ops.OpOverload.__call__", "arguments": {"args": {"self": {"torch._ops.profiler.profiler::_record_function_exit._RecordFunction": {"is_view": false, "namespace": "profiler"}}, "args": {"torch._RecordFunction": {}}}, "func_name": "torch._ops.OpOverload.__call__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.autograd.profiler.record_function.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.autograd.profiler.record_function.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.autograd.profiler.record_function.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.profiler.record_function.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.distributed.utils._recursive_to <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.utils._recursive_to", "arguments": {"args": {"inputs": {"tuple": {}}, "use_side_stream_for_tensor_copies": {"bool": true}}, "func_name": "torch.distributed.utils._recursive_to"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.distributed.utils._to_kwargs <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.distributed.utils._to_kwargs", "arguments": {"args": {"inputs": {"tuple": {}}, "kwargs": {"dict": {}}, "use_side_stream_for_tensor_copies": {"bool": true}}, "func_name": "torch.distributed.utils._to_kwargs"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.modules.linear.Linear.forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.modules.module.Module._call_impl <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module._call_impl"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.modules.module.Module._wrapped_call_impl <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.module.Module._wrapped_call_impl"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._check_sync_bufs_post_fwd <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._check_sync_bufs_post_fwd"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._check_sync_bufs_pre_fwd <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._check_sync_bufs_pre_fwd"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._clear_grad_buffer <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._clear_grad_buffer"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._inside_ddp_forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._inside_ddp_forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._post_forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._post_forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._pre_forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._pre_forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel._run_ddp_forward <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel._run_ddp_forward"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.distributed.DistributedDataParallel.will_sync_module_buffers <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.will_sync_module_buffers"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.nn.parallel.distributed.DistributedDataParallel.forward contains torch.nn.parallel.scatter_gather._is_namedtuple <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.scatter_gather._is_namedtuple", "arguments": {"args": {"obj": {"tuple": {}}}, "func_name": "torch.nn.parallel.scatter_gather._is_namedtuple"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_add <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_", "arguments": {"args": {"alpha": {"float": -1.0}}, "func_name": "torch._VariableFunctionsClass._foreach_add_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_addcmul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_", "arguments": {"args": {"value": {"float": 0.09999999999999998}}, "func_name": "torch._VariableFunctionsClass._foreach_addcmul_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_div_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_mul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass._foreach_sqrt_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._VariableFunctionsClass.is_complex <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.is_complex"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.optim.adadelta.Adadelta._init_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta._init_group", "arguments": {"args": {"self": {"torch.optim.adadelta.Adadelta": {}}, "group": {"dict": {}}, "params_with_grad": {"list": []}, "grads": {"list": []}, "square_avgs": {"list": []}, "acc_deltas": {"list": []}}, "func_name": "torch.optim.adadelta.Adadelta._init_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.optim.adadelta._multi_tensor_adadelta <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adadelta._multi_tensor_adadelta", "arguments": {"args": {"lr": {"float": 1.0}, "rho": {"float": 0.9}, "eps": {"float": 1e-06}, "weight_decay": {"int": 0}, "maximize": {"bool": false}, "differentiable": {"bool": false}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "square_avgs": {"list": {}}, "acc_deltas": {"list": {}}}, "func_name": "torch.optim.adadelta._multi_tensor_adadelta"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.optim.adadelta.adadelta <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta", "arguments": {"args": {"lr": {"float": 1.0}, "rho": {"float": 0.9}, "eps": {"float": 1e-06}, "weight_decay": {"int": 0}, "foreach": {"NoneType": null}, "maximize": {"bool": false}, "differentiable": {"bool": false}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "square_avgs": {"list": {}}, "acc_deltas": {"list": {}}}, "func_name": "torch.optim.adadelta.adadelta"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.Adadelta.step contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.Adadelta.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_add <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_", "arguments": {"args": {"alpha": {"float": -1.0}}, "func_name": "torch._VariableFunctionsClass._foreach_add_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_addcmul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_", "arguments": {"args": {"value": {"float": 0.09999999999999998}}, "func_name": "torch._VariableFunctionsClass._foreach_addcmul_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_div_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_mul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._VariableFunctionsClass._foreach_sqrt_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.optim.adadelta._multi_tensor_adadelta <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adadelta._multi_tensor_adadelta", "arguments": {"args": {"lr": {"float": 1.0}, "rho": {"float": 0.9}, "eps": {"float": 1e-06}, "weight_decay": {"int": 0}, "maximize": {"bool": false}, "differentiable": {"bool": false}, "has_complex": {"bool": false}, "params": {"list": {}}, "grads": {"list": {}}, "square_avgs": {"list": {}}, "acc_deltas": {"list": {}}}, "func_name": "torch.optim.adadelta._multi_tensor_adadelta"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adadelta.adadelta contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adadelta.adadelta"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_addcdiv_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcdiv_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_addcmul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_div_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_lerp_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_lerp_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_mul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass._foreach_sqrt <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass.equal <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.equal"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass.is_complex <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.is_complex"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._VariableFunctionsClass.tensor <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tensor"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.backends.cuda.is_built <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.backends.cuda.is_built"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.cuda.graphs.is_current_stream_capturing <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.graphs.is_current_stream_capturing"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.adam.Adam._init_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam._init_group", "arguments": {"args": {"self": {"torch.optim.adam.Adam": {}}, "group": {"dict": {}}, "params_with_grad": {"list": []}, "grads": {"list": []}, "exp_avgs": {"list": []}, "exp_avg_sqs": {"list": []}, "max_exp_avg_sqs": {"list": []}, "state_steps": {"list": []}}, "func_name": "torch.optim.adam.Adam._init_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check", "arguments": {"args": {"self": {"torch.optim.adam.Adam": {}}}, "func_name": "torch.optim.optimizer.Optimizer._cuda_graph_capture_health_check"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.optimizer._dispatch_sqrt <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._dispatch_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.optimizer._get_value <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._get_value"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.optim.optimizer._stack_if_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._stack_if_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.Adam.step contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.Adam.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_addcdiv_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcdiv_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_addcmul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_addcmul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_div_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_div_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_lerp_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_lerp_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_mul_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_mul_"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass._foreach_sqrt <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass.equal <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.equal"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._VariableFunctionsClass.tensor <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass.tensor", "arguments": {"args": {"device": {"str": "cpu"}}, "func_name": "torch._VariableFunctionsClass.tensor"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.cuda._is_compiled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._is_compiled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.cuda._nvml_based_avail <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._nvml_based_avail"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.cuda.is_available <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_available"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"use_fused": {"bool": false}, "params": {"list": {}}, "differentiable": {"bool": false}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.optim.optimizer._dispatch_sqrt <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._dispatch_sqrt"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.optim.optimizer._get_value <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._get_value"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.optim.optimizer._stack_if_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._stack_if_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.adam.adam contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.adam.adam"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": false}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.lr_scheduler.LRScheduler.step contains torch.optim.lr_scheduler.StepLR.get_lr <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler.LRScheduler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler.StepLR.get_lr", "arguments": {"args": {"self": {"torch.optim.lr_scheduler.StepLR": {"gamma": 0.7, "last_epoch": 0, "step_size": 1, "verbose": false}}}, "func_name": "torch.optim.lr_scheduler.StepLR.get_lr"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.torch/optim/lr_scheduler.py:__init__.step_size", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [-1.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.lr_scheduler.LRScheduler.step contains torch.optim.lr_scheduler._enable_get_lr_call.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler.LRScheduler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler._enable_get_lr_call.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.torch/optim/lr_scheduler.py:__init__.step_size", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [-1.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.lr_scheduler.LRScheduler.step contains torch.optim.lr_scheduler._enable_get_lr_call.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler.LRScheduler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler._enable_get_lr_call.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.torch/optim/lr_scheduler.py:__init__.step_size", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [-1.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.lr_scheduler.LRScheduler.step contains torch.optim.lr_scheduler._enable_get_lr_call.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler.LRScheduler.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.lr_scheduler._enable_get_lr_call.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.torch/optim/lr_scheduler.py:__init__.step_size", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [-1.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.optimizer.Optimizer.register_step_post_hook contains torch.utils.hooks.RemovableHandle.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.optimizer.Optimizer.register_step_post_hook"}, {"param_type": "APIParam", "api_full_name": "torch.utils.hooks.RemovableHandle.__init__", "arguments": {"args": {"self": {"torch.utils.hooks.RemovableHandle": {"next_id": 0}}, "hooks_dict": {"OrderedDict": {}}}, "func_name": "torch.utils.hooks.RemovableHandle.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_", "arguments": {"args": {"alpha": {"float": -0.001}}, "func_name": "torch._VariableFunctionsClass._foreach_add_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"differentiable": {"bool": false}, "use_fused": {"bool": false}, "params": {"list": {}}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.optim.sgd.SGD._init_group <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD._init_group", "arguments": {"args": {"self": {"torch.optim.sgd.SGD": {}}, "group": {"dict": {}}, "params_with_grad": {"list": []}, "d_p_list": {"list": []}, "momentum_buffer_list": {"list": []}}, "func_name": "torch.optim.sgd.SGD._init_group"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.SGD.step contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.SGD.step"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": true}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch._VariableFunctionsClass._foreach_add_ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch._VariableFunctionsClass._foreach_add_", "arguments": {"args": {"alpha": {"float": -0.001}}, "func_name": "torch._VariableFunctionsClass._foreach_add_"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch._utils.is_compiling <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch._utils.is_compiling"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.autograd.grad_mode.no_grad.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.autograd.grad_mode.no_grad.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.autograd.grad_mode.no_grad.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.no_grad.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.autograd.grad_mode.set_grad_enabled.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.autograd.grad_mode.set_grad_enabled.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.is_grad_enabled <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.is_grad_enabled"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.optim.optimizer._default_to_fused_or_foreach <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.optim.optimizer._default_to_fused_or_foreach", "arguments": {"args": {"differentiable": {"bool": false}, "use_fused": {"bool": false}, "params": {"list": {}}}, "func_name": "torch.optim.optimizer._default_to_fused_or_foreach"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.utils._foreach_utils._get_foreach_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_foreach_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.utils._foreach_utils._get_fused_kernels_supported_devices <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._get_fused_kernels_supported_devices"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.optim.sgd.sgd contains torch.utils._foreach_utils._group_tensors_by_device_and_dtype <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.optim.sgd.sgd"}, {"param_type": "APIParam", "api_full_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype", "arguments": {"args": {"tensorlistlist": {"list": {}}, "with_indices": {"bool": true}}, "func_name": "torch.utils._foreach_utils._group_tensors_by_device_and_dtype"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.random.manual_seed contains torch.cuda._lazy_call <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.random.manual_seed"}, {"param_type": "APIParam", "api_full_name": "torch.cuda._lazy_call", "arguments": {"args": {"seed_all": {"bool": true}, "callable": {"torch.cuda.random.manual_seed_all.<locals>.cb": {}}}, "func_name": "torch.cuda._lazy_call"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.random.manual_seed contains torch.cuda.is_initialized <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.random.manual_seed"}, {"param_type": "APIParam", "api_full_name": "torch.cuda.is_initialized"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.random.manual_seed contains torch.random._seed_custom_device <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.random.manual_seed"}, {"param_type": "APIParam", "api_full_name": "torch.random._seed_custom_device"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._namedtensor_internals.check_serializing_named_tensor <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._namedtensor_internals.check_serializing_named_tensor"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._tensor.Tensor._reduce_ex_internal <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._tensor.Tensor._reduce_ex_internal", "arguments": {"args": {"proto": {"int": 2}}, "func_name": "torch._tensor.Tensor._reduce_ex_internal"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._tensor.Tensor._typed_storage <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._tensor.Tensor._typed_storage"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._utils._element_size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._utils._element_size", "arguments": {"args": {"dtype": {"torch.dtype": "torch.float32"}}, "func_name": "torch._utils._element_size"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._utils._get_obj_state <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._utils._get_obj_state"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch._utils.get_tensor_metadata <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch._utils.get_tensor_metadata"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.is_storage <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.is_storage"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._check_dill_version <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._check_dill_version", "arguments": {"args": {"pickle_module": {"pickle": {"DEFAULT_PROTOCOL": 4, "HIGHEST_PROTOCOL": 5, "format_version": "4.0", "maxsize": 9223372036854775807}}}, "func_name": "torch.serialization._check_dill_version"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._check_save_filelike <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._check_save_filelike", "arguments": {"args": {"f": {"str": "checkpoint.pt"}}, "func_name": "torch.serialization._check_save_filelike"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._is_path <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._is_path", "arguments": {"args": {"name_or_buffer": {"str": "checkpoint.pt"}}, "func_name": "torch.serialization._is_path"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._open_zipfile_writer <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._open_zipfile_writer", "arguments": {"args": {"name_or_buffer": {"str": "checkpoint.pt"}}, "func_name": "torch.serialization._open_zipfile_writer"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._open_zipfile_writer_file.__exit__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._open_zipfile_writer_file.__exit__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._open_zipfile_writer_file.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._open_zipfile_writer_file.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._opener.__enter__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._opener.__enter__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._opener.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._opener.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization._save <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization._save", "arguments": {"args": {"obj": {"OrderedDict": {}}, "zip_file": {"torch.PyTorchFileWriter": {}}, "pickle_module": {"pickle": {"DEFAULT_PROTOCOL": 4, "HIGHEST_PROTOCOL": 5, "format_version": "4.0", "maxsize": 9223372036854775807}}, "pickle_protocol": {"int": 2}, "_disable_byteorder_record": {"bool": false}}, "func_name": "torch.serialization._save"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.serialization.location_tag <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.serialization.location_tag", "arguments": {"args": {"storage": {"torch.storage.UntypedStorage": {"is_cuda": true, "is_hpu": false, "is_sparse": false, "is_sparse_csr": false}}}, "func_name": "torch.serialization.location_tag"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage.TypedStorage.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage.TypedStorage.__init__", "arguments": {"args": {"wrap_storage": {"torch.storage.UntypedStorage": {"is_cuda": true, "is_hpu": false, "is_sparse": false, "is_sparse_csr": false}}, "dtype": {"torch.dtype": "torch.float32"}, "_internal": {"bool": true}, "self": {"torch.storage.TypedStorage": {"is_sparse": false}}}, "func_name": "torch.storage.TypedStorage.__init__"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage.TypedStorage._element_size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage.TypedStorage._element_size", "arguments": {"args": {"self": {"torch.storage.TypedStorage": {"dtype": "torch.float32", "is_cuda": true, "is_hpu": false, "is_sparse": false}}}, "func_name": "torch.storage.TypedStorage._element_size"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage.TypedStorage._pickle_storage_type <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage.TypedStorage._pickle_storage_type", "arguments": {"args": {"self": {"torch.storage.TypedStorage": {"dtype": "torch.float32", "is_cuda": true, "is_hpu": false, "is_sparse": false}}}, "func_name": "torch.storage.TypedStorage._pickle_storage_type"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage.TypedStorage._size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage.TypedStorage._size", "arguments": {"args": {"self": {"torch.storage.TypedStorage": {"dtype": "torch.float32", "is_cuda": true, "is_hpu": false, "is_sparse": false}}}, "func_name": "torch.storage.TypedStorage._size"}}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage._StorageBase.__init__ <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage._StorageBase.__init__"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage._StorageBase.cpu <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage._StorageBase.cpu"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.storage._StorageBase.size <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.storage._StorageBase.size"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "torch.serialization.save contains torch.utils.hooks.warn_if_has_hooks <class 'traincheck.invariant.base_cls._NOT_SET'>", "relation": "APIContainRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.serialization.save"}, {"param_type": "APIParam", "api_full_name": "torch.utils.hooks.warn_if_has_hooks"}], "precondition": {"parent_func_call_pre": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140218046580544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2058668]}, {"type": "constant", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [3.0]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.cuda.FloatTensor.ndim and torch.cuda.FloatTensor.ndim", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.cuda.FloatTensor", "attr_name": "ndim"}, {"param_type": "VarTypeParam", "var_type": "torch.cuda.FloatTensor", "attr_name": "ndim"}], "precondition": {"var": {"inverted": true, "preconditions": [{"clauses": [{"type": "unequal", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float"}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.nn.Parameter.data and torch.nn.Parameter.data", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "data"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "data"}], "precondition": {"var": {"inverted": false, "preconditions": [{"clauses": [{"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net.weight"]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [2.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [1200.0]}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_grad_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [60.0]}, {"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net.bias"]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_grad_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [60.0]}, {"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [2.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_grad_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net2.weight"]}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net2.bias"]}, {"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [4.0]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_grad_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.nn.Parameter.grad and torch.cuda.FloatTensor.data", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad"}, {"param_type": "VarTypeParam", "var_type": "torch.cuda.FloatTensor", "attr_name": "data"}], "precondition": {"var": {"inverted": false, "preconditions": [{"clauses": [{"type": "unequal", "prop_name": "attributes._ML_DAIKON_grad_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "attributes.requires_grad", "additional_path": "None", "prop_dtype": "bool"}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.nn.Parameter.grad and torch.nn.Parameter.grad", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "grad"}], "precondition": {"var": {"inverted": false, "preconditions": [{"clauses": [{"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net.weight"]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [2.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [1200.0]}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [60.0]}, {"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net.bias"]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [60.0]}, {"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [2.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net2.weight"]}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}, {"clauses": [{"type": "unequal", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int"}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}, {"type": "unequal", "prop_name": "attributes._ML_DAIKON_data_ID", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float", "values": [1.0]}, {"type": "consistent", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float"}, {"type": "unequal", "prop_name": "meta_vars._DATA_PARALLEL_RANK", "additional_path": "None", "prop_dtype": "float"}, {"type": "constant", "prop_name": "var_name", "additional_path": "None", "prop_dtype": "str", "values": ["net2.bias"]}, {"type": "constant", "prop_name": "attributes.nbytes", "additional_path": "None", "prop_dtype": "float", "values": [4.0]}, {"type": "unequal", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int"}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.nn.Parameter.ndim and torch.cuda.FloatTensor.ndim", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "ndim"}, {"param_type": "VarTypeParam", "var_type": "torch.cuda.FloatTensor", "attr_name": "ndim"}], "precondition": {"var": {"inverted": true, "preconditions": [{"clauses": [{"type": "unequal", "prop_name": "attributes.ndim", "additional_path": "None", "prop_dtype": "float"}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "Consistency Relation between torch.nn.Parameter.ndim and torch.nn.Parameter.ndim", "relation": "ConsistencyRelation", "params": [{"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "ndim"}, {"param_type": "VarTypeParam", "var_type": "torch.nn.Parameter", "attr_name": "ndim"}], "precondition": {"var": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 100 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 1048576 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 12 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 128 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 128 is consistent across the input [1, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 128 is consistent across the input [2, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 2, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 128 is consistent across the input [3, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 3, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 128 is consistent across the input [4, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 4, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 1433 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 16384 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 173312 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 173312 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 173312 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'itemsize'] and output [1, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [0, 'ndim'] and output [1, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [1, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [1, 'ndim'] and output [0, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2 is consistent across the input [1, 'ndim'] and output [1, 'ndim'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2048 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2048 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 234664448 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 234664448 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 234664448 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 256 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 26 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 26 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 26 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 26 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 2] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 2] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 2] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 1] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 1] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 1] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 1] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 2708 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 32 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 3276800 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'shape', 2] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'shape', 2] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'shape', 3] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [0, 'shape', 3] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'itemsize'] and output [1, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'nbytes'] and output [0, 'itemsize'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'shape', 2] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'shape', 2] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'shape', 3] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'ndim'] and output [0, 'shape', 3] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'itemsize'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'itemsize'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'ndim'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'ndim'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'itemsize'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'itemsize'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'ndim'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [2064493]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140385080473408]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'ndim'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [1, 'itemsize'] and output [1, 'itemsize'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [2, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 2, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [2, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 2, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [3, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 3, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [3, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 3, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [4, 'itemsize'] and output [0, 'itemsize'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 4, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4 is consistent across the input [4, 'itemsize'] and output [0, 'ndim'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 4, "type": "torch.Tensor", "additional_path": ["itemsize"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 0] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [0, 'shape', 1] and output [1, 'shape', 1] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [1, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 4096 is consistent across the input [1, 'shape', 1] and output [1, 'shape', 1] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 0] and output [1, 'shape', 0] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [1, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 512 is consistent across the input [1, 'shape', 0] and output [1, 'shape', 0] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 1] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 0] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 2] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 64 is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 67108864 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 693248 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 7 is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 75824 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8 is consistent across the input [0, 'shape', 0] and output [0, 'shape', 0] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 0], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [0, 'nbytes'] and output [1, 'nbytes'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [1, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 8388608 is consistent across the input [1, 'nbytes'] and output [1, 'nbytes'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value 91712 is consistent across the input [0, 'nbytes'] and output [0, 'nbytes'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["nbytes"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ipu'] and output [0, 'is_ipu'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_meta'] and output [0, 'is_meta'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mkldnn'] and output [0, 'is_mkldnn'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mps'] and output [0, 'is_mps'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_mtia'] and output [0, 'is_mtia'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_nested'] and output [0, 'is_nested'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_ort'] and output [0, 'is_ort'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_quantized'] and output [0, 'is_quantized'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse'] and output [0, 'is_sparse'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_sparse_csr'] and output [0, 'is_sparse_csr'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_vulkan'] and output [0, 'is_vulkan'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xla'] and output [0, 'is_xla'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'is_xpu'] and output [0, 'is_xpu'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [0, 'retains_grad'] and output [0, 'retains_grad'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_cpu'] and output [1, 'is_cpu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_ipu'] and output [1, 'is_ipu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_ipu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_meta'] and output [1, 'is_meta'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_meta"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_mkldnn'] and output [1, 'is_mkldnn'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mkldnn"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_mps'] and output [1, 'is_mps'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mps"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_mtia'] and output [1, 'is_mtia'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_mtia"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_nested'] and output [1, 'is_nested'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_nested"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_ort'] and output [1, 'is_ort'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_ort"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_quantized'] and output [1, 'is_quantized'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_quantized"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_sparse'] and output [1, 'is_sparse'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_sparse"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_sparse_csr'] and output [1, 'is_sparse_csr'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_sparse_csr"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_vulkan'] and output [1, 'is_vulkan'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_vulkan"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_xla'] and output [1, 'is_xla'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_xla"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'is_xpu'] and output [1, 'is_xpu'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_xpu"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'requires_grad'] and output [1, 'requires_grad'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value False is consistent across the input [1, 'retains_grad'] and output [1, 'retains_grad'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["retains_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cpu'] and output [0, 'is_cpu'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cpu"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_cuda'] and output [0, 'is_cuda'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'is_leaf'] and output [0, 'is_leaf'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'ndim'] and output [0, 'ndim'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["ndim"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'requires_grad'] and output [0, 'requires_grad'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["requires_grad"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'shape', 1] and output [0, 'shape', 1] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 1], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'shape', 2] and output [0, 'shape', 2] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 2], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [0, 'shape', 3] and output [0, 'shape', 3] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["shape", 3], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [1, 'is_cuda'] and output [1, 'is_cuda'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_cuda"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value True is consistent across the input [1, 'is_leaf'] and output [1, 'is_leaf'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["is_leaf"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.cuda.amp.grad_scaler.GradScaler.scale.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.cuda.amp.grad_scaler.GradScaler.scale", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.boolean_dispatch.<locals>.fn.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.boolean_dispatch.<locals>.fn", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.dropout.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.dropout", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.dropout", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.elu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.elu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.elu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.leaky_relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.leaky_relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.leaky_relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.log_softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.log_softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.log_softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.nll_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.nll_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.nll_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.relu.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.relu", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.relu", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.softmax.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.softmax", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.softmax", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.kaiming_uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.kaiming_uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.ones_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.ones_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.ones_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.uniform_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.uniform_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.uniform_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.xavier_normal_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.xavier_normal_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.xavier_normal_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.init.zeros_.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.zeros_", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.init.zeros_", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.activation.LeakyReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.LeakyReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.activation.ReLU.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.ReLU.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.activation.Sigmoid.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.Sigmoid.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.activation.Tanh.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.activation.Tanh.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.container.Sequential.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.container.Sequential.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.conv.Conv2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.conv.Conv2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.conv.ConvTranspose2d.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.conv.ConvTranspose2d.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.dropout.Dropout.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.dropout.Dropout.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.linear.Linear.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.linear.Linear.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.NLLLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.NLLLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.parallel.distributed.DistributedDataParallel.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [0, 'dtype'] and output [1, 'dtype'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.binary_cross_entropy.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.binary_cross_entropy_with_logits.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.binary_cross_entropy_with_logits", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.mse_loss.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.mse_loss", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.mse_loss", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.BCELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.BCEWithLogitsLoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.modules.loss.MSELoss.forward.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.modules.loss.MSELoss.forward", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [1, 'dtype'] and output [1, 'dtype'] tensors of the function torch.functional.broadcast_tensors.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 1, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.functional.broadcast_tensors", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [2, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 2, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [3, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 3, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "The value torch.float32 is consistent across the input [4, 'dtype'] and output [0, 'dtype'] tensors of the function torch.nn.functional.batch_norm.", "relation": "ConsistentInputOutputRelation", "params": [{"param_type": "InputOutputParam", "name": "input_tensors", "index": 4, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": true}, {"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "InputOutputParam", "name": "output_tensors", "index": 0, "type": "torch.Tensor", "additional_path": ["dtype"], "api_name": "torch.nn.functional.batch_norm", "is_input": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.functional.broadcast_tensors is consistently torch.float16.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float16"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.functional.broadcast_tensors is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.batch_norm is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.dropout is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.elu is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.leaky_relu is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.log_softmax is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.mse_loss is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.nll_loss is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.relu is consistently torch.float16.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float16"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.relu is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.functional.softmax is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.normal_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.ones_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.uniform_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.init.zeros_ is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently torch.float16.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float16"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently torch.float16.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float16"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently torch.float16.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float16"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "dtype of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently torch.float32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "dtype", "const_value": "torch.float32"}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.ones_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cpu of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.functional.broadcast_tensors is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.batch_norm is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.dropout is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.elu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.leaky_relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.log_softmax is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.mse_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.nll_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.functional.softmax is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_cuda of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_cuda", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ipu of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ipu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}, {"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [139629751805760]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [378776]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}, {"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [139629751805760]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [378776]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.ones_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.init.zeros_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["training"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}, {"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [139629751805760]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [378776]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_leaf of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_leaf", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_meta of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_meta", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mkldnn of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mkldnn", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mps of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mps", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_mtia of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_mtia", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_nested of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_nested", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_ort of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_ort", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_quantized of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_quantized", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_sparse_csr of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_sparse_csr", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_vulkan of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_vulkan", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xla of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xla", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "is_xpu of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "is_xpu", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.functional.broadcast_tensors is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.functional.broadcast_tensors is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.batch_norm is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.dropout is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.elu is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.leaky_relu is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.log_softmax is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.mse_loss is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.nll_loss is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.relu is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.relu is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.functional.softmax is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.normal_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.ones_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.uniform_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.init.zeros_ is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "itemsize of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "itemsize", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.functional.broadcast_tensors is consistently 4194304.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4194304}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.functional.broadcast_tensors is consistently 8388608.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 8388608}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.dropout is consistently 173312.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 173312}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.elu is consistently 693248.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 693248}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.mse_loss is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.nll_loss is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.functional.relu is consistently 173312.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 173312}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently 67108864.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 67108864}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.init.uniform_ is consistently 16384.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 16384}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently 4194304.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4194304}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 173312.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 173312}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently 4194304.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4194304}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "exist", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast", "additional_path": "None", "prop_dtype": "None"}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.dtype", "additional_path": "None", "prop_dtype": "str", "values": ["torch.float16"]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.device_type", "additional_path": "None", "prop_dtype": "str", "values": ["cuda"]}, {"type": "constant", "prop_name": "meta_vars.context_managers.torch.amp.autocast_mode.autocast.enabled", "additional_path": ["enabled"], "prop_dtype": "bool", "values": [true]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "nbytes of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently 32.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "nbytes", "const_value": 32}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.functional.broadcast_tensors is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.batch_norm is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.elu is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.leaky_relu is consistently 3.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 3}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.log_softmax is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.mse_loss is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.nll_loss is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.functional.softmax is consistently 3.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 3}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.init.ones_ is consistently 1.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 1}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.init.uniform_ is consistently 1.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 1}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.init.zeros_ is consistently 1.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 1}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently 3.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 3}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140709991028544]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374789]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently 4.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 4}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently 0.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 0}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "ndim of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently 2.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "ndim", "const_value": 2}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.batch_norm is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.mse_loss is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}, {"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [139629751805760]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [378776]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.functional.relu is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": true, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["evaluation"]}]}, {"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [139629751805760]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [378776]}, {"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [50.0]}, {"type": "constant", "prop_name": "meta_vars.stage", "additional_path": "None", "prop_dtype": "str", "values": ["testing"]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.ones_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.uniform_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.init.zeros_ is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "requires_grad of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently True.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "requires_grad", "const_value": true}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.functional.broadcast_tensors is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.multiprocessing.reductions.rebuild_tensor is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.multiprocessing.reductions.rebuild_tensor"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.batch_norm is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.batch_norm"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.boolean_dispatch.<locals>.fn is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.boolean_dispatch.<locals>.fn"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.dropout is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.elu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.leaky_relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.leaky_relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.log_softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.log_softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.mse_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.nll_loss is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.relu is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.functional.softmax is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.softmax"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.ones_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.ones_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.uniform_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.xavier_normal_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.xavier_normal_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.init.zeros_ is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.zeros_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.activation.LeakyReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.LeakyReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.activation.Sigmoid.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Sigmoid.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.activation.Tanh.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.Tanh.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.conv.Conv2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.Conv2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.conv.ConvTranspose2d.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.conv.ConvTranspose2d.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "retains_grad of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently False.", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "retains_grad", "const_value": false}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.cuda.amp.grad_scaler.GradScaler.scale is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.cuda.amp.grad_scaler.GradScaler.scale"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.functional.broadcast_tensors is consistently (512, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.functional.broadcast_tensors"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [512, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.binary_cross_entropy is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.binary_cross_entropy_with_logits is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.binary_cross_entropy_with_logits"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.dropout is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.dropout"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.elu is consistently (2708, 64).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.elu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 64]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.mse_loss is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.mse_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.nll_loss is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.nll_loss"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.relu is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.functional.relu is consistently (512, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.functional.relu"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [512, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.init.kaiming_uniform_ is consistently (4096, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.kaiming_uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [4096, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.init.uniform_ is consistently (4096,).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.init.uniform_"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.activation.ReLU.forward is consistently (512, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.activation.ReLU.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [512, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.container.Sequential.forward is consistently (512, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.container.Sequential.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [512, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.dropout.Dropout.forward is consistently (2708, 16).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.dropout.Dropout.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [2708, 16]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "meta_vars.step", "additional_path": "None", "prop_dtype": "float", "values": [0.0]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [374887]}, {"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140336029759296]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.linear.Linear.forward is consistently (512, 4096).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.linear.Linear.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [512, 4096]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": [{"type": "constant", "prop_name": "thread_id", "additional_path": "None", "prop_dtype": "int", "values": [140058748933952]}, {"type": "constant", "prop_name": "process_id", "additional_path": "None", "prop_dtype": "int", "values": [372344]}]}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.loss.BCELoss.forward is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.loss.BCEWithLogitsLoss.forward is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.BCEWithLogitsLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.loss.MSELoss.forward is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.MSELoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.modules.loss.NLLLoss.forward is consistently ().", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.modules.loss.NLLLoss.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": []}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}
{"text_description": "shape of the tensors returned by the function torch.nn.parallel.distributed.DistributedDataParallel.forward is consistently (8, 1).", "relation": "ConsistentOutputRelation", "params": [{"param_type": "APIParam", "api_full_name": "torch.nn.parallel.distributed.DistributedDataParallel.forward"}, {"param_type": "VarTypeParam", "var_type": "torch.Tensor", "attr_name": "shape", "const_value": [8, 1]}], "precondition": {"pre_event": {"inverted": false, "preconditions": [{"clauses": "Unconditional"}]}}, "num_positive_examples": null, "num_negative_examples": null}